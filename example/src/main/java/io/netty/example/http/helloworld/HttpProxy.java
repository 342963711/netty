package io.netty.example.http.helloworld;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.DefaultFullHttpResponse;import io.netty.handler.codec.http.DefaultHttpRequest;import io.netty.handler.codec.http.FullHttpRequest;import io.netty.handler.codec.http.FullHttpResponse;import io.netty.handler.codec.http.HttpContent;import io.netty.handler.codec.http.HttpHeaders;import io.netty.handler.codec.http.HttpMessage;import io.netty.handler.codec.http.HttpObject;import io.netty.handler.codec.http.HttpRequest;import io.netty.handler.codec.http.HttpUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.nio.charset.Charset;import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;import static io.netty.handler.codec.http.HttpHeaderValues.TEXT_PLAIN;import static io.netty.handler.codec.http.HttpResponseStatus.OK;/** * @author likai * @date 2024/6/30 21:21 * @email likai9376@163.com * @desc */public class HttpProxy extends SimpleChannelInboundHandler<HttpObject> {    private static Logger LOGGER = LoggerFactory.getLogger(HttpHelloWorldServerHandler.class);    private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };    @Override    public void channelReadComplete(ChannelHandlerContext ctx) {        ctx.flush();    }    @Override    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {        if(msg instanceof FullHttpRequest){            String uri = ((FullHttpRequest) msg).uri();            HttpHeaders headers = ((FullHttpRequest) msg).headers();            ByteBuf content = ((FullHttpRequest) msg).content();            LOGGER.info("uri:{},header:{},content:{}",uri,headers,content.toString(Charset.forName("utf-8")));            boolean keepAlive = HttpUtil.isKeepAlive((HttpMessage) msg);            FullHttpResponse response = new DefaultFullHttpResponse(((HttpMessage) msg).protocolVersion(), OK,                                                                    Unpooled.wrappedBuffer(CONTENT));            response.headers()                    .set(CONTENT_TYPE, TEXT_PLAIN)                    .setInt(CONTENT_LENGTH, response.content().readableBytes());            if (keepAlive) {                if (((HttpMessage) msg).protocolVersion().isKeepAliveDefault()) {                    response.headers().set(CONNECTION, KEEP_ALIVE);                }            } else {                // Tell the client we're going to close the connection.                response.headers().set(CONNECTION, CLOSE);            }            ChannelFuture f = ctx.write(response);            if (!keepAlive) {                f.addListener(ChannelFutureListener.CLOSE);            }        }//        if(msg instanceof HttpContent){//            LOGGER.info("msg-Content:{}",((HttpContent) msg).content().toString(Charset.forName("utf-8")));//        }//        if (msg instanceof HttpRequest) {//            HttpRequest req = (HttpRequest) msg;//            if(msg instanceof DefaultHttpRequest){//                DefaultHttpRequest fullHttpRequest = (DefaultHttpRequest)msg;//                String uri = fullHttpRequest.getUri();//                LOGGER.info("请求路径:{}",uri);//            }//            LOGGER.info("msg:{}",msg);//            boolean keepAlive = HttpUtil.isKeepAlive(req);//            FullHttpResponse response = new DefaultFullHttpResponse(req.protocolVersion(), OK,//                                                                    Unpooled.wrappedBuffer(CONTENT));//            response.headers()//                    .set(CONTENT_TYPE, TEXT_PLAIN)//                    .setInt(CONTENT_LENGTH, response.content().readableBytes());////            if (keepAlive) {//                if (!req.protocolVersion().isKeepAliveDefault()) {//                    response.headers().set(CONNECTION, KEEP_ALIVE);//                }//            } else {//                // Tell the client we're going to close the connection.//                response.headers().set(CONNECTION, CLOSE);//            }////            ChannelFuture f = ctx.write(response);////            if (!keepAlive) {//                f.addListener(ChannelFutureListener.CLOSE);//            }//        }    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {        cause.printStackTrace();        ctx.close();    }}